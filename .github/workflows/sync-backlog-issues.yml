name: Sync Backlog Issues

on:
  push:
    branches: [ main ]
    paths:
      - 'backlog/issues.yaml'
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install parser
        run: npm i js-yaml@4.1.0

      - name: Sync backlog/issues.yaml to GitHub issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const content = fs.readFileSync('backlog/issues.yaml', 'utf8');
          const doc = yaml.load(content);
          const repo = process.env.GITHUB_REPOSITORY;
          if (!repo) { throw new Error('GITHUB_REPOSITORY not set'); }
          const [owner, name] = repo.split('/');
          const token = process.env.GITHUB_TOKEN;
          if (!token) { throw new Error('GITHUB_TOKEN not set'); }
          const fetchJson = async (url, init = {}) => {
            const headers = Object.assign({
              authorization: 'Bearer ' + token,
              accept: 'application/vnd.github+json'
            }, init.headers || {});
            while (true) {
              const res = await fetch(url, Object.assign({}, init, { headers }));
              if (res.status === 403) {
                const remaining = Number(res.headers.get('x-ratelimit-remaining') || '0');
                const resetSec = Number(res.headers.get('x-ratelimit-reset') || '0');
                if (remaining === 0 && resetSec) {
                  const waitMs = resetSec * 1000 - Date.now() + 1000;
                  if (waitMs > 0 && waitMs < 300000) {
                    console.log(`Rate limited. Sleeping ${waitMs}ms until reset...`);
                    await new Promise(r => setTimeout(r, waitMs));
                    continue;
                  }
                }
              }
              if (!res.ok) {
                const t = await res.text();
                throw new Error(`HTTP ${res.status} ${res.statusText}: ${t}`);
              }
              return res.json();
            }
          };
          const updateIssue = async (num, body) => {
            await fetchJson(`https://api.github.com/repos/${owner}/${name}/issues/${num}`, {
              method: 'PATCH',
              body: JSON.stringify({ body })
            });
          };
          (async () => {
            if (!doc || !Array.isArray(doc.issues)) return;
            for (const it of doc.issues) {
              const code = it.code;
              const title = it.title;
              const body = typeof it.body === 'string' ? it.body : '';
              if (!code || !title) continue;
              const q = encodeURIComponent(`repo:${owner}/${name} is:issue in:title ${code}`);
              const search = await fetchJson(`https://api.github.com/search/issues?q=${q}&per_page=1`);
              const item = search.items && search.items[0];
              if (!item) continue;
              // Only update if body differs to avoid noise
              if ((item.body || '').trim() !== body.trim()) {
                await updateIssue(item.number, body);
                console.log(`Updated #${item.number} (${code})`);
              } else {
                console.log(`No change for #${item.number} (${code})`);
              }
              // Small throttle between requests
              await new Promise(r => setTimeout(r, 200));
            }
          })().catch(err => { console.error(err); process.exit(1); });
          NODE
