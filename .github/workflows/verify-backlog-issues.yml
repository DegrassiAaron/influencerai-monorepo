name: Verify Backlog Issues

on:
  push:
    branches: [ main ]
    paths:
      - 'backlog/issues.yaml'
  pull_request:
    paths:
      - 'backlog/issues.yaml'
  workflow_dispatch:

permissions:
  contents: read
  issues: read

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install parser
        run: npm i js-yaml@4.1.0

      - name: Verify DoD-complete issues are closed on GitHub
        env:
          # Prefer a read-only PAT to avoid org/app installation rate limits.
          # Fallback to the default GITHUB_TOKEN if no PAT is configured.
          # Define one of these in repo/org secrets: GH_PAT_READ or GH_TOKEN or PAT_READ_CONTENTS
          GITHUB_TOKEN: ${{ secrets.GH_PAT_READ || secrets.GH_TOKEN || secrets.PAT_READ_CONTENTS || secrets.GITHUB_TOKEN }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const content = fs.readFileSync('backlog/issues.yaml', 'utf8');
          const doc = yaml.load(content);
          const repo = process.env.GITHUB_REPOSITORY;
          if (!repo) throw new Error('GITHUB_REPOSITORY not set');
          const [owner, name] = repo.split('/');
          const token = process.env.GITHUB_TOKEN;
          if (!token) throw new Error('GITHUB_TOKEN not set');
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));
          const fetchJson = async (url, init = {}) => {
            const headers = Object.assign({
              authorization: 'Bearer ' + token,
              accept: 'application/vnd.github+json'
            }, init.headers || {});
            let attempt = 0;
            const maxAttempts = 6; // ~ up to ~1+2+4+8+16+32 = 63s backoff
            let lastErr;
            while (attempt < maxAttempts) {
              try {
                const res = await fetch(url, Object.assign({}, init, { headers }));
                const remaining = res.headers.get('x-ratelimit-remaining');
                const status = res.status;
                if (status === 429 || status === 403 || remaining === '0') {
                  // Rate limited: compute backoff
                  const reset = parseInt(res.headers.get('x-ratelimit-reset') || '0', 10);
                  const now = Math.floor(Date.now() / 1000);
                  const waitSec = Math.max( (reset ? (reset - now) : 0), Math.min(2 ** attempt, 32));
                  await sleep(waitSec * 1000);
                  attempt++;
                  continue;
                }
                if (!res.ok) {
                  const t = await res.text();
                  throw new Error(`HTTP ${res.status} ${res.statusText}: ${t}`);
                }
                return res.status === 204 ? null : res.json();
              } catch (e) {
                lastErr = e;
                // network/transient error -> backoff
                const waitMs = Math.min(2 ** attempt * 1000, 32000);
                await sleep(waitMs);
                attempt++;
              }
            }
            throw lastErr || new Error('fetchJson failed after retries');
          };
          const errors = [];
          (async () => {
            if (!doc || !Array.isArray(doc.issues)) return;
            for (const it of doc.issues) {
              const code = it.code;
              const title = it.title;
              const body = typeof it.body === 'string' ? it.body : '';
              if (!code || !title) continue;
              const anyChecked = /- \[x\]/i.test(body);
              const anyUnchecked = /- \[ \]/.test(body);
              const shouldBeClosed = anyChecked && !anyUnchecked;
              if (!shouldBeClosed) continue;
              const q = encodeURIComponent(`repo:${owner}/${name} is:issue in:title ${code}`);
              const search = await fetchJson(`https://api.github.com/search/issues?q=${q}&per_page=1`);
              const item = search.items && search.items[0];
              if (!item) {
                errors.push(`Issue with code ${code} not found on GitHub`);
                continue;
              }
              if ((item.state || '').toLowerCase() !== 'closed') {
                errors.push(`#${item.number} (${code}) is not closed while DoD is complete`);
              }
              await sleep(150);
            }
          })()
            .then(() => {
              if (errors.length) {
                console.error('Verification failed:\n' + errors.map(e => '- ' + e).join('\n'));
                process.exit(1);
              } else {
                console.log('All DoD-complete issues are closed.');
              }
            })
            .catch(err => { console.error(err); process.exit(1); });
          NODE
