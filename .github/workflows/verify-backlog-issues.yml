name: Verify Backlog Issues

on:
  push:
    branches: [ main ]
    paths:
      - 'backlog/issues.yaml'
  pull_request:
    paths:
      - 'backlog/issues.yaml'
  workflow_dispatch:

permissions:
  contents: read
  issues: read

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install parser
        run: npm i js-yaml@4.1.0

      - name: Verify DoD-complete issues are closed on GitHub
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const content = fs.readFileSync('backlog/issues.yaml', 'utf8');
          const doc = yaml.load(content);
          const repo = process.env.GITHUB_REPOSITORY;
          if (!repo) throw new Error('GITHUB_REPOSITORY not set');
          const [owner, name] = repo.split('/');
          const token = process.env.GITHUB_TOKEN;
          if (!token) throw new Error('GITHUB_TOKEN not set');
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));
          const fetchJson = async (url, init = {}) => {
            const headers = Object.assign({
              authorization: 'Bearer ' + token,
              accept: 'application/vnd.github+json'
            }, init.headers || {});
            const res = await fetch(url, Object.assign({}, init, { headers }));
            if (!res.ok) {
              const t = await res.text();
              throw new Error(`HTTP ${res.status} ${res.statusText}: ${t}`);
            }
            return res.status === 204 ? null : res.json();
          };
          const errors = [];
          (async () => {
            if (!doc || !Array.isArray(doc.issues)) return;
            for (const it of doc.issues) {
              const code = it.code;
              const title = it.title;
              const body = typeof it.body === 'string' ? it.body : '';
              if (!code || !title) continue;
              const anyChecked = /- \[x\]/i.test(body);
              const anyUnchecked = /- \[ \]/.test(body);
              const shouldBeClosed = anyChecked && !anyUnchecked;
              if (!shouldBeClosed) continue;
              const q = encodeURIComponent(`repo:${owner}/${name} is:issue in:title ${code}`);
              const search = await fetchJson(`https://api.github.com/search/issues?q=${q}&per_page=1`);
              const item = search.items && search.items[0];
              if (!item) {
                errors.push(`Issue with code ${code} not found on GitHub`);
                continue;
              }
              if ((item.state || '').toLowerCase() !== 'closed') {
                errors.push(`#${item.number} (${code}) is not closed while DoD is complete`);
              }
              await sleep(150);
            }
          })()
            .then(() => {
              if (errors.length) {
                console.error('Verification failed:\n' + errors.map(e => '- ' + e).join('\n'));
                process.exit(1);
              } else {
                console.log('All DoD-complete issues are closed.');
              }
            })
            .catch(err => { console.error(err); process.exit(1); });
          NODE
