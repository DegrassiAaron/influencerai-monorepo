name: Issue Intake - Create Issue

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      app:
        description: Which app env
        required: true
        type: choice
        options: [app-foo, app-bar]
      title:
        description: Issue title
        required: true
      type:
        description: feature|fix|chore|docs|test
        required: true
        default: feature
      priority:
        description: P0|P1|P2|P3
        required: false
        default: P2
      area:
        description: api|ui|db|infra|e2e|security|deps
        required: false
        default: ""
      size:
        description: XS|S|M|L|XL
        required: false
        default: M
      assignees:
        description: comma-separated @users
        required: false
        default: ""

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  gate:
    runs-on: ubuntu-latest
    outputs:
      run: ${{ steps.gate.outputs.run }}
      app: ${{ steps.gate.outputs.app }}
      title: ${{ steps.gate.outputs.title }}
      type: ${{ steps.gate.outputs.type }}
      priority: ${{ steps.gate.outputs.priority }}
      area: ${{ steps.gate.outputs.area }}
      size: ${{ steps.gate.outputs.size }}
      assignees: ${{ steps.gate.outputs.assignees }}
    steps:
      - id: gate
        run: |
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            body=$(jq -r '.comment.body' < "$GITHUB_EVENT_PATH")
            if [[ "$body" =~ ^/issue[[:space:]]+new ]]; then
              kv(){ echo "$body" | sed -n "s/.*$1:\([^ ]*\).*/\1/p" | head -n1; }
              qv(){ echo "$body" | sed -n "s/.*$1:\"\([^\"]\+\)\".*/\1/p" | head -n1; }
              app=$(kv app); [[ -z "$app" ]] && app=app-foo
              t=$(kv type); [[ -z "$t" ]] && t=feature
              ttl=$(qv title); [[ -z "$ttl" ]] && ttl=New
              prio=$(kv priority); [[ -z "$prio" ]] && prio=P2
              area=$(kv area); size=$(kv size)
              asg=$(echo "$body" | sed -n "s/.*assign:\([^ ]*\).*/\1/p" | head -n1)
              {
                echo "run=true"
                echo "app=$app"
                echo "title=$ttl"
                echo "type=$t"
                echo "priority=$prio"
                echo "area=$area"
                echo "size=$size"
                echo "assignees=$asg"
              } >> "$GITHUB_OUTPUT"
            else
              echo "run=false" >> "$GITHUB_OUTPUT"
            fi
          else
            {
              echo "run=true"
              echo "app=${{ inputs.app }}"
              echo "title=${{ inputs.title }}"
              echo "type=${{ inputs.type }}"
              echo "priority=${{ inputs.priority }}"
              echo "area=${{ inputs.area }}"
              echo "size=${{ inputs.size }}"
              echo "assignees=${{ inputs.assignees }}"
            } >> "$GITHUB_OUTPUT"
          fi

  create_issue:
    needs: gate
    if: needs.gate.outputs.run == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.gate.outputs.app }}
    steps:
      - name: Normalize and build labels
        id: meta
        env:
          TITLE: ${{ needs.gate.outputs.title }}
          TYPE: ${{ needs.gate.outputs.type }}
          PRIORITY: ${{ needs.gate.outputs.priority }}
          AREA: ${{ needs.gate.outputs.area }}
          SIZE: ${{ needs.gate.outputs.size }}
        run: |
          norm() { echo "$1" | tr '[:upper:]' '[:lower:]'; }
          t=$(norm "$TYPE"); prio=$(norm "$PRIORITY"); area=$(norm "$AREA"); size=$(norm "$SIZE")
          case "$t" in feature|fix|chore|docs|test) ;; *) t=feature ;; esac
          case "$prio" in p0|p1|p2|p3|p0-critical|p1-high|p2-medium|p3-low) ;; *) prio=p2 ;; esac
          labels=("type: $t" "status: todo")
          if [[ "$prio" =~ ^p[0-3]$ ]]; then
            labels+=("priority: ${prio^^}")
          else
            labels+=("priority: ${prio}")
          fi
          [[ -n "$area" ]] && labels+=("area: $area")
          [[ -n "$size" ]] && labels+=("size: ${size^^}")
          printf "%s\n" "${labels[@]}" > labels.txt
          slug=$(echo "$TITLE" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+|-+$//g')
          echo "labels=$(paste -sd, - < labels.txt)" >> "$GITHUB_OUTPUT"
          echo "slug=$slug" >> "$GITHUB_OUTPUT"

      - name: Create issue
        id: issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          template="feature.md"
          [[ "${{ needs.gate.outputs.type }}" == "fix" ]] && template="bug.md"
          num=$(gh issue create \
            --title "${{ needs.gate.outputs.title }}" \
            --label "${{ steps.meta.outputs.labels }}" \
            --template "$template" \
            --json number \
            --jq .number)
          echo "number=$num" >> "$GITHUB_OUTPUT"

      - name: Ensure DoD checklist in issue body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          num=${{ steps.issue.outputs.number }}
          body=$(gh issue view "$num" --json body -q .body)
          printf "%s" "$body" > issue.md
          if ! grep -q "^## Checklist DoD" issue.md; then
            cat <<'EOF' >> issue.md

## Checklist DoD
- [ ] Lint/format ok
- [ ] Test locali passano
- [ ] E2E/UX aggiornati (se serve)
- [ ] Docs/Changelog aggiornati
- [ ] Migrazioni verificate
- [ ] Conferma manuale maintainer (manual)
EOF
            gh issue edit "$num" --body-file issue.md
          fi

      - name: Comment with branch suggestion
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          number=${{ steps.issue.outputs.number }}
          type=${{ needs.gate.outputs.type }}
          slug=${{ steps.meta.outputs.slug }}
          cat <<EOF > comment.md
**Branch suggerito**:
\`$type/$number-$slug\`

Comandi:
\`\`\`bash
git switch develop && git pull
git switch -c $type/$number-$slug
\`\`\`
EOF
          gh issue comment "$number" --body-file comment.md

      - name: Assign (optional)
        if: ${{ needs.gate.outputs.assignees != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IFS=',' read -r -a arr <<< "${{ needs.gate.outputs.assignees }}"
          gh issue edit ${{ steps.issue.outputs.number }} --add-assignee "${arr[@]}"
