name: Issue Intake â€” Create Issue

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      app: { description: "Which app env", required: true, type: choice, options: [app-foo, app-bar] }
      title: { description: "Issue title", required: true }
      type:  { description: "feature|fix|chore|docs|test", required: true, default: feature }
      priority: { description: "P0|P1|P2|P3", required: false, default: P2 }
      area:  { description: "api|ui|db|infra|e2e|security|deps", required: false, default: "" }
      size:  { description: "XS|S|M|L|XL", required: false, default: M }
      assignees: { description: "comma-separated @users", required: false, default: "" }

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  gate:
    runs-on: ubuntu-latest
    outputs:
      run: ${{ steps.gate.outputs.run }}
      app: ${{ steps.gate.outputs.app }}
      title: ${{ steps.gate.outputs.title }}
      type: ${{ steps.gate.outputs.type }}
      priority: ${{ steps.gate.outputs.priority }}
      area: ${{ steps.gate.outputs.area }}
      size: ${{ steps.gate.outputs.size }}
      assignees: ${{ steps.gate.outputs.assignees }}
    steps:
      - id: gate
        run: |
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            body=$(jq -r '.comment.body' < "$GITHUB_EVENT_PATH")
            if [[ "$body" =~ ^/issue[[:space:]]+new ]]; then
              kv(){ echo "$body" | sed -n "s/.*$1:\([^ ]*\).*/\1/p" | head -n1; }
              qv(){ echo "$body" | sed -n "s/.*$1:\"\([^\"]\+\)\".*/\1/p" | head -n1; }
              app=$(kv app); [ -z "$app" ] && app=app-foo
              t=$(kv type); [ -z "$t" ] && t=feature
              ttl=$(qv title); [ -z "$ttl" ] && ttl=New
              prio=$(kv priority); [ -z "$prio" ] && prio=P2
              area=$(kv area); size=$(kv size)
              asg=$(echo "$body" | sed -n "s/.*assign:\([^ ]*\).*/\1/p" | head -n1)
              echo "run=true" >> $GITHUB_OUTPUT
              echo "app=$app" >> $GITHUB_OUTPUT
              echo "title=$ttl" >> $GITHUB_OUTPUT
              echo "type=$t" >> $GITHUB_OUTPUT
              echo "priority=$prio" >> $GITHUB_OUTPUT
              echo "area=$area" >> $GITHUB_OUTPUT
              echo "size=$size" >> $GITHUB_OUTPUT
              echo "assignees=$asg" >> $GITHUB_OUTPUT
            else
              echo "run=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "run=true" >> $GITHUB_OUTPUT
            echo "app=${{ inputs.app }}" >> $GITHUB_OUTPUT
            echo "title=${{ inputs.title }}" >> $GITHUB_OUTPUT
            echo "type=${{ inputs.type }}" >> $GITHUB_OUTPUT
            echo "priority=${{ inputs.priority }}" >> $GITHUB_OUTPUT
            echo "area=${{ inputs.area }}" >> $GITHUB_OUTPUT
            echo "size=${{ inputs.size }}" >> $GITHUB_OUTPUT
            echo "assignees=${{ inputs.assignees }}" >> $GITHUB_OUTPUT
          fi

  create_issue:
    needs: gate
    if: needs.gate.outputs.run == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.gate.outputs.app }}
    steps:
      - uses: cli/cli@v2
      - name: Normalize & build labels
        id: meta
        env:
          TITLE: ${{ needs.gate.outputs.title }}
          TYPE: ${{ needs.gate.outputs.type }}
          PRIORITY: ${{ needs.gate.outputs.priority }}
          AREA: ${{ needs.gate.outputs.area }}
          SIZE: ${{ needs.gate.outputs.size }}
        run: |
          norm() { echo "$1" | tr '[:upper:]' '[:lower:]'; }
          t=$(norm "$TYPE"); prio=$(norm "$PRIORITY"); area=$(norm "$AREA"); size=$(norm "$SIZE")
          case "$t" in feature|fix|chore|docs|test) ;; *) t=feature ;; esac
          case "$prio" in p0|p1|p2|p3|p0-critical|p1-high|p2-medium|p3-low) ;; *) prio=p2 ;; esac
          lbls=("type: $t" "status: todo")
          [[ "$prio" =~ ^p[0-3]$ ]] && lbls+=("priority: ${prio^^}") || lbls+=("priority: ${prio}")
          [ -n "$area" ] && lbls+=("area: $area")
          [ -n "$size" ] && lbls+=("size: ${size^^}")
          printf "%s
" "${lbls[@]}" > labels.txt
          slug=$(echo "$TITLE" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+|-+$//g')
          echo "labels=$(paste -sd, - < labels.txt)" >> $GITHUB_OUTPUT
          echo "slug=$slug" >> $GITHUB_OUTPUT

      - name: Create issue
        id: issue
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          tmpl="feature.md"; [ "${{ needs.gate.outputs.type }}" = "fix" ] && tmpl="bug.md"
          num=$(gh issue create --title "${{ needs.gate.outputs.title }}" --label "${{ steps.meta.outputs.labels }}" --template "$tmpl" --json number --jq .number)
          echo "number=$num" >> $GITHUB_OUTPUT

      - name: Ensure DoD checklist in Issue body
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          num=${{ steps.issue.outputs.number }}
          body=$(gh issue view "$num" --json body -q .body)
          printf "%s" "$body" > issue.md
          if ! grep -q "^## Checklist DoD" issue.md; then
            cat <<'EOF' >> issue.md

## Checklist DoD
- [ ] Lint/format ok
- [ ] Test locali passano
- [ ] E2E/UX aggiornati (se serve)
- [ ] Docs/Changelog aggiornati
- [ ] Migrazioni verificate
- [ ] Conferma manuale maintainer (manual)
EOF
            gh issue edit "$num" --body-file issue.md
          fi

      - name: Comment with branch suggestion
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          n=${{ steps.issue.outputs.number }}
          t=${{ needs.gate.outputs.type }}
          slug=${{ steps.meta.outputs.slug }}
          echo "**Branch suggerito**:" > c.md
          echo "\`$t/$n-$slug\`" >> c.md
          echo "" >> c.md
          echo "Comandi:" >> c.md
          echo "\`\`\`bash" >> c.md
          echo "git switch develop && git pull" >> c.md
          echo "git switch -c $t/$n-$slug" >> c.md
          echo "\`\`\`" >> c.md
          gh issue comment "$n" --body-file c.md

      - name: Assign (optional)
        if: ${{ needs.gate.outputs.assignees != '' }}
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          IFS=',' read -r -a arr <<< "${{ needs.gate.outputs.assignees }}"
          gh issue edit ${{ steps.issue.outputs.number }} --add-assignee "${arr[@]}"
